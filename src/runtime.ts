// tslint:disable:no-require-imports
import get = require('lodash.get');
import toPath = require('lodash.topath');
// tslint:enable:no-require-imports
import * as path from 'path';
import {
	AbstractSyntaxTree,
	BinaryExpressionNode,
	BranchesNode,
	ExpressionNode,
	IncludeNode,
	isBinaryOperator,
	isBranchesNode,
	isIncludeNode,
	isTextLiteralNode,
	isUnaryOperator,
	isValueNode,
	isVariableNode,
	StatementNode,
	UnaryExpressionNode,
} from './abstract-syntax-tree';
import {FileLoadError} from './error/file-load';
import {
	RuntimeError,
	RuntimeExpressionError,
	RuntimeMaximumCallStackExceededError,
	RuntimeReadError,
	RuntimeReferenceError,
} from './error/runtime';
import {BinaryOperator, UnaryOperator} from './operator';
import {TemplateLoader} from './template-loader';

/**
 * Safely compare two floating point numbers
 * @param a The first number
 * @param b The second number
 * @param epsilon The allowed difference between the values
 * @returns True if values match, else false
 */
function floatEqual(a: number, b: number, epsilon: number): boolean {
	if (a === b) {
		return true;
	}

	// infinity is difficult
	if (
		(a === Number.POSITIVE_INFINITY && b === Number.NEGATIVE_INFINITY)
		|| (b === Number.POSITIVE_INFINITY && a === Number.NEGATIVE_INFINITY)
	) {
		return false;
	}

	const diff = Math.abs(a - b);
	return diff <= epsilon || diff <= Math.min(Math.abs(a), Math.abs(b)) * epsilon;
}

export interface RunnerOptions {
	epsilon?: number;
	rootPath?: string;
	maximumCallDepth?: number;
}

type Value = boolean | string | number;

export interface InputData {
	[name: string]: InputData | Value;
}

/**
 * Guard for InputData
 * @param value The value to check
 * @returns True if the value provided is InputData
 */
function isInputData(value: InputData | Value): value is InputData {
	return typeof value === 'object';
}

/**
 * The runtime for sql statements abstract syntax tress
 */
export class Runtime {
	private readonly templateLoader: TemplateLoader;
	private readonly epsilon: number;
	private readonly rootPath: string;
	private readonly maximumCallDepth: number;
	private result: string[];
	private callDepth: number;
	private input: InputData;
	private currentDataPath: string;
	private templatePath: string;

	public constructor(templateLoader: TemplateLoader, options: RunnerOptions = {}) {
		this.templateLoader = templateLoader;
		this.epsilon = options.epsilon || Number.EPSILON;
		this.rootPath = options.rootPath || process.cwd();
		this.maximumCallDepth = options.maximumCallDepth || 64;
		this.result = [];
		this.callDepth = 0;
		this.input = {};
		this.currentDataPath = '';
		this.templatePath = '';
	}

	/**
	 * Invoke the abstract syntax tree (AST) against a set of input variable
	 * @param abstractSyntaxTree The AST generated by Parser
	 * @param input An input objects that is passed along to the AST
	 * @returns Resolves to an array of the output lines
	 * @throws {RuntimeError} if there was unexpected statement, an expression error, an invalid template path or a data
	 * path reference error
	 * @throws {RuntimeReadError} if there was an error reading a template file
	 * @throws {RuntimeMaximumCallStackExceededError} if the maximum call depth is exceeded
	 */
	public async invoke(abstractSyntaxTree: AbstractSyntaxTree, input: InputData): Promise<string[]> {
		this.callDepth = 0;
		this.result = [];
		this.input = input;
		this.currentDataPath = '';
		this.templatePath = abstractSyntaxTree.templatePath;
		await this.invokeStatements(abstractSyntaxTree.statements);
		return this.result;
	}

	/**
	 * Evaluate if two values are equal, automatically handling numeric values
	 * @param leftValue The left side of the equality
	 * @param rightValue The right side of the equality
	 * @param strict If true comparison will also ensure types match
	 * @returns If the left and right values are equal
	 */
	private evaluateEquals(leftValue: Value, rightValue: Value, strict = false): boolean {
		if (typeof leftValue === 'number' && typeof rightValue === 'number') {
			return floatEqual(leftValue, rightValue, this.epsilon);
		}
		// eslint-disable-next-line eqeqeq
		return strict ? leftValue === rightValue : leftValue == rightValue;
	}

	/**
	 * Evaluate a unary expression returning the result of the evaluation
	 * @param expression The unary expression
	 * @returns The result of the evaluation
	 * @throws {RuntimeExpressionError} if there was an unknown operator
	 */
	private evaluateUnaryExpression(expression: UnaryExpressionNode): boolean {
		if (expression.operator === UnaryOperator.Not) {
			return !this.evaluateExpression(expression.expression);
		}

		throw new RuntimeExpressionError('Unknown operator', expression);
	}

	/**
	 * Resolve a variable from the input value data
	 * @param pathName The path to the value being resolved
	 * @returns Returns a primitive if the input value if a leaf on the graph, else an object
	 * @throws {RuntimeReferenceError} if the data path does not exist on input
	 */
	private getValueFromVariable(pathName: string): Value | InputData {
		const dataPath = toPath(this.currentDataPath ? `${this.currentDataPath}.${pathName}` : pathName);
		// dataPath.length cannot currently be 0
		if (dataPath.length === 1) {
			return get(this.input, dataPath);
		}
		// eslint-disable-next-line typescript/no-non-null-assertion
		const property: string = dataPath.pop()!;
		const obj = get(this.input, dataPath);
		if (typeof obj !== 'object') {
			throw new RuntimeReferenceError(
				`${property} is not defined`,
				this.currentDataPath ? `${this.currentDataPath}.${pathName}` : pathName
			);
		}
		return obj[property];
	}

	/**
	 * Get the resolved template path
	 * @param templatePath The input template path, that may be relative
	 * @returns The absolute template path
	 */
	private getResolvedTemplatePath(templatePath: string): string {
		if (path.isAbsolute(templatePath)) {
			return path.resolve(templatePath);
		}

		if (templatePath[0] === '.' && this.templatePath !== '<anonymous>') {
			return path.resolve(path.dirname(this.templatePath), templatePath);
		}
		return path.resolve(this.rootPath, templatePath);
	}

	/**
	 * Evaluate a binary expression returning the result of the evaluation
	 * @param expression The expression to resolve
	 * @returns The result of the evaluation
	 * @throws {RuntimeExpressionError} if there was an unknown operator
	 */
	private evaluateBinaryExpression(expression: BinaryExpressionNode): boolean {
		const leftValue = this.evaluateExpression(expression.left);
		const rightValue = this.evaluateExpression(expression.right);

		switch (expression.operator) {
			case BinaryOperator.Or:
				return Boolean(leftValue || rightValue);
			case BinaryOperator.And:
				return Boolean(leftValue && rightValue);
			case BinaryOperator.LessThan:
				return leftValue < rightValue;
			case BinaryOperator.LessEqualThan:
				return leftValue < rightValue || this.evaluateEquals(leftValue, rightValue);
			case BinaryOperator.GreaterEqualThan:
				return leftValue > rightValue || this.evaluateEquals(leftValue, rightValue);
			case BinaryOperator.StrictNotEquals:
				return !this.evaluateEquals(leftValue, rightValue, true);
			case BinaryOperator.StrictEquals:
				return this.evaluateEquals(leftValue, rightValue, true);
			case BinaryOperator.NotEquals:
				return !this.evaluateEquals(leftValue, rightValue);
			case BinaryOperator.Equals:
				return this.evaluateEquals(leftValue, rightValue);
			case BinaryOperator.GreaterThan:
				return leftValue > rightValue;
			default:
				throw new RuntimeExpressionError('Unknown operator', expression);
		}
	}

	/**
	 * Import and revoke an include statement
	 * @param statement The included statement
	 * @returns Resolves after the included statement is imported and invoked
	 * @throws {RuntimeError} if there was unexpected statement, an expression error, an invalid template path or a data
	 * path reference error
	 * @throws {RuntimeReadError} if there was an error reading a template file
	 * @throws {RuntimeMaximumCallStackExceededError} if the maximum call depth is exceeded
	 * @throws {RuntimeReferenceError} if the data path does not exist on input
	 * @throws {RuntimeExpressionError} if there was an unknown operator
	 */
	private async invokeInclude(statement: IncludeNode): Promise<void> {
		const rawTemplatePath = isVariableNode(statement.value)
			? this.getValueFromVariable(statement.value.name)
			: statement.value.value;

		if (typeof rawTemplatePath !== 'string') {
			throw new RuntimeError('Non-string type passed as path', statement, `${rawTemplatePath}`);
		}
		const templatePath = this.getResolvedTemplatePath(rawTemplatePath);

		this.callDepth++;
		if (this.callDepth > this.maximumCallDepth) {
			throw new RuntimeMaximumCallStackExceededError(statement, this.templatePath);
		}
		const previousTemplatePath = this.templatePath;
		const previousDataPath = this.currentDataPath;
		if (statement.dataPath) {
			const newDataPath = this.currentDataPath
				? `${this.currentDataPath}.${this.evaluateExpression(statement.dataPath)}`
				: this.evaluateExpression(statement.dataPath);
			if (typeof newDataPath !== 'string') {
				throw new RuntimeError(`Invalid data path: ${newDataPath}`, statement, templatePath);
			}
			this.currentDataPath = newDataPath;
		}
		const abstractSyntaxTree = await this.templateLoader(templatePath);

		this.templatePath = templatePath;
		try {
			await this.invokeStatements(abstractSyntaxTree.statements);
		}
		catch (err) {
			this.currentDataPath = previousDataPath;
			this.templatePath = previousTemplatePath;
			this.callDepth--;
			throw err;
		}
		this.currentDataPath = previousDataPath;
		this.templatePath = previousTemplatePath;
		this.callDepth--;
	}

	/**
	 * Check the condition of a branching statement invoking the first statement with a condition that returns true
	 * @param statement The branching statement
	 * @returns Resolves true if a branch was invoked, else false
	 * @throws {RuntimeExpressionError} if there in invalid type used in expression or there was an unknown expression
	 * @throws {RuntimeError} if there was unexpected statement, an expression error, an invalid template path or a data
	 * path reference error
	 * @throws {RuntimeReadError} if there was an error reading a template file
	 * @throws {RuntimeMaximumCallStackExceededError} if the maximum call depth is exceeded
	 */
	private async invokeBranch(statement: BranchesNode): Promise<boolean> {
		for (const branch of statement.branches) {
			if (branch.condition === undefined || this.evaluateExpression(branch.condition)) {
				await this.invokeStatements(branch.consequent.statements);
				return true;
			}
		}
		return false;
	}

	/**
	 * Evaluate an expression retuning the result of the evaluation
	 * @param expression The expression
	 * @returns Returns the result of the evaluation
	 * @throws {RuntimeExpressionError} if there in invalid type used in expression, there was an unknown expression, or
	 * there was an unknown operator
	 * @throws {RuntimeReferenceError} if a data path does not exist on input
	 */
	private evaluateExpression(expression: ExpressionNode): Value {
		if (isBinaryOperator(expression)) {
			return this.evaluateBinaryExpression(expression);
		}

		if (isUnaryOperator(expression)) {
			return this.evaluateUnaryExpression(expression);
		}

		if (isValueNode(expression)) {
			return expression.value;
		}

		if (isVariableNode(expression)) {
			const value = this.getValueFromVariable(expression.name);
			if (isInputData(value)) {
				throw new RuntimeExpressionError('Invalid use of object in expression', expression);
			}
			return value;
		}
		throw new RuntimeExpressionError('Unknown expression type', expression);
	}

	/**
	 * Invoke a list if statements
	 * @param statements The statements list
	 * @returns Resolves once all the statements have been invoked
	 * @throws {RuntimeError} if there was unexpected statement, an expression error, an invalid template path or a data
	 * path reference error
	 * @throws {RuntimeReadError} if there was an error reading a template file
	 * @throws {RuntimeMaximumCallStackExceededError} if the maximum call depth is exceeded
	 */
	private async invokeStatements(statements: StatementNode[]): Promise<void> {
		/* eslint-disable no-await-in-loop */
		for (const statement of statements) {
			try {
				if (isTextLiteralNode(statement)) {
					this.result.push(statement.value);
				}
				else if (isIncludeNode(statement)) {
					await this.invokeInclude(statement);
				}
				else if (isBranchesNode(statement)) {
					await this.invokeBranch(statement);
				}
				else {
					throw new RuntimeError('Unexpected statement', statement, this.templatePath);
				}
			}
			catch (e) {
				if (e instanceof RuntimeMaximumCallStackExceededError) {
					e.pushStatementStack(statement, this.templatePath);
				}
				else if (e instanceof RuntimeExpressionError) {
					throw new RuntimeError(e.message, statement, this.templatePath, e);
				}
				else if (e instanceof RuntimeReferenceError) {
					throw new RuntimeError(e.message, statement, this.templatePath, e);
				}
				else if (e instanceof FileLoadError) {
					throw new RuntimeReadError('Error loading template file', statement, this.templatePath, e);
				}
				throw e;
			}
		}
		/* eslint-enable no-await-in-loop */
	}
}
